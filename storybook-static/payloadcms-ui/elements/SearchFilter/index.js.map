{"version":3,"file":"index.js","names":["React","useEffect","useRef","useState","usePathname","useDebounce","baseClass","SearchFilter","props","handleChange","initialParams","label","pathname","search","setSearch","undefined","shouldUpdateState","previousSearch","debouncedSearch","current","_jsx","className","id","onChange","e","target","value","placeholder","type"],"sources":["../../../src/elements/SearchFilter/index.tsx"],"sourcesContent":["'use client'\nimport React, { useEffect, useRef, useState } from 'react'\n\nexport type SearchFilterProps = {\n  fieldName?: string\n  handleChange?: (search: string) => void\n  initialParams?: ParsedQs\n  label: string\n  setValue?: (arg: string) => void\n  value?: string\n}\n\nimport type { ParsedQs } from 'qs-esm'\n\nimport { usePathname } from 'next/navigation.js'\n\nimport { useDebounce } from '../../hooks/useDebounce.js'\nimport './index.scss'\n\nconst baseClass = 'search-filter'\n\nexport const SearchFilter: React.FC<SearchFilterProps> = (props) => {\n  const { handleChange, initialParams, label } = props\n  const pathname = usePathname()\n  const [search, setSearch] = useState(\n    typeof initialParams?.search === 'string' ? initialParams?.search : undefined,\n  )\n\n  /**\n   * Tracks whether the state should be updated based on the search value.\n   * If the value is updated from the URL, we don't want to update the state as it causes additional renders.\n   */\n  const shouldUpdateState = useRef(true)\n\n  /**\n   * Tracks the previous search value to compare with the current debounced search value.\n   */\n  const previousSearch = useRef(\n    typeof initialParams?.search === 'string' ? initialParams?.search : undefined,\n  )\n\n  const debouncedSearch = useDebounce(search, 300)\n\n  useEffect(() => {\n    if (initialParams?.search !== previousSearch.current) {\n      shouldUpdateState.current = false\n      setSearch(initialParams?.search as string)\n      previousSearch.current = initialParams?.search as string\n    }\n  }, [initialParams?.search, pathname])\n\n  useEffect(() => {\n    if (debouncedSearch !== previousSearch.current && shouldUpdateState.current) {\n      if (handleChange) {\n        handleChange(debouncedSearch)\n      }\n\n      previousSearch.current = debouncedSearch\n    }\n  }, [debouncedSearch, handleChange])\n\n  return (\n    <div className={baseClass}>\n      <input\n        aria-label={label}\n        className={`${baseClass}__input`}\n        id=\"search-filter-input\"\n        onChange={(e) => {\n          shouldUpdateState.current = true\n          setSearch(e.target.value)\n        }}\n        placeholder={label}\n        type=\"text\"\n        value={search || ''}\n      />\n    </div>\n  )\n}\n"],"mappings":"AAAA;;;AACA,OAAOA,KAAA,IAASC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ;AAanD,SAASC,WAAW,QAAQ;AAE5B,SAASC,WAAW,QAAQ;AAC5B,OAAO;AAEP,MAAMC,SAAA,GAAY;AAElB,OAAO,MAAMC,YAAA,GAA6CC,KAAA;EACxD,MAAM;IAAEC,YAAY;IAAEC,aAAa;IAAEC;EAAK,CAAE,GAAGH,KAAA;EAC/C,MAAMI,QAAA,GAAWR,WAAA;EACjB,MAAM,CAACS,MAAA,EAAQC,SAAA,CAAU,GAAGX,QAAA,CAC1B,OAAOO,aAAA,EAAeG,MAAA,KAAW,WAAWH,aAAA,EAAeG,MAAA,GAASE,SAAA;EAGtE;;;;EAIA,MAAMC,iBAAA,GAAoBd,MAAA,CAAO;EAEjC;;;EAGA,MAAMe,cAAA,GAAiBf,MAAA,CACrB,OAAOQ,aAAA,EAAeG,MAAA,KAAW,WAAWH,aAAA,EAAeG,MAAA,GAASE,SAAA;EAGtE,MAAMG,eAAA,GAAkBb,WAAA,CAAYQ,MAAA,EAAQ;EAE5CZ,SAAA,CAAU;IACR,IAAIS,aAAA,EAAeG,MAAA,KAAWI,cAAA,CAAeE,OAAO,EAAE;MACpDH,iBAAA,CAAkBG,OAAO,GAAG;MAC5BL,SAAA,CAAUJ,aAAA,EAAeG,MAAA;MACzBI,cAAA,CAAeE,OAAO,GAAGT,aAAA,EAAeG,MAAA;IAC1C;EACF,GAAG,CAACH,aAAA,EAAeG,MAAA,EAAQD,QAAA,CAAS;EAEpCX,SAAA,CAAU;IACR,IAAIiB,eAAA,KAAoBD,cAAA,CAAeE,OAAO,IAAIH,iBAAA,CAAkBG,OAAO,EAAE;MAC3E,IAAIV,YAAA,EAAc;QAChBA,YAAA,CAAaS,eAAA;MACf;MAEAD,cAAA,CAAeE,OAAO,GAAGD,eAAA;IAC3B;EACF,GAAG,CAACA,eAAA,EAAiBT,YAAA,CAAa;EAElC,oBACEW,IAAA,CAAC;IAAIC,SAAA,EAAWf,SAAA;cACd,aAAAc,IAAA,CAAC;MACC,cAAYT,KAAA;MACZU,SAAA,EAAW,GAAGf,SAAA,SAAkB;MAChCgB,EAAA,EAAG;MACHC,QAAA,EAAWC,CAAA;QACTR,iBAAA,CAAkBG,OAAO,GAAG;QAC5BL,SAAA,CAAUU,CAAA,CAAEC,MAAM,CAACC,KAAK;MAC1B;MACAC,WAAA,EAAahB,KAAA;MACbiB,IAAA,EAAK;MACLF,KAAA,EAAOb,MAAA,IAAU;;;AAIzB","ignoreList":[]}