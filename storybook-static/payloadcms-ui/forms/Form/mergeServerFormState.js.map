{"version":3,"file":"mergeServerFormState.js","names":["dequal","mergeErrorPaths","mergeServerFormState","acceptValues","existingState","incomingState","changed","newState","serverPropsToAccept","push","path","newFieldState","Object","entries","fieldChanged","errorPathsResult","errorPaths","result","filterOptions","forEach","prop","valid","passesCondition","field"],"sources":["../../../src/forms/Form/mergeServerFormState.ts"],"sourcesContent":["'use client'\nimport { dequal } from 'dequal/lite' // lite: no need for Map and Set support\nimport { type FormState } from 'payload'\n\nimport { mergeErrorPaths } from './mergeErrorPaths.js'\n\ntype Args = {\n  acceptValues?: boolean\n  existingState: FormState\n  incomingState: FormState\n}\n\n/**\n * Merges certain properties from the server state into the client state. These do not include values,\n * as we do not want to update them on the client like that, which would cause flickering.\n *\n * We want to use this to update the error state, and other properties that are not user input, as the error state\n * is the thing we want to keep in sync with the server (where it's calculated) on the client.\n */\nexport const mergeServerFormState = ({\n  acceptValues,\n  existingState,\n  incomingState,\n}: Args): { changed: boolean; newState: FormState } => {\n  let changed = false\n\n  const newState = {}\n\n  if (existingState) {\n    const serverPropsToAccept = [\n      'passesCondition',\n      'valid',\n      'errorMessage',\n      'errorPaths',\n      'rows',\n      'customComponents',\n      'requiresRender',\n    ]\n\n    if (acceptValues) {\n      serverPropsToAccept.push('value')\n      serverPropsToAccept.push('initialValue')\n    }\n\n    for (const [path, newFieldState] of Object.entries(existingState)) {\n      if (!incomingState[path]) {\n        continue\n      }\n      let fieldChanged = false\n\n      /**\n       * Handle error paths\n       */\n      const errorPathsResult = mergeErrorPaths(\n        newFieldState.errorPaths,\n        incomingState[path].errorPaths as unknown as string[],\n      )\n      if (errorPathsResult.result) {\n        if (errorPathsResult.changed) {\n          changed = errorPathsResult.changed\n        }\n        newFieldState.errorPaths = errorPathsResult.result\n      }\n\n      /**\n       * Handle filterOptions\n       */\n      if (incomingState[path]?.filterOptions || newFieldState.filterOptions) {\n        if (!dequal(incomingState[path]?.filterOptions, newFieldState.filterOptions)) {\n          changed = true\n          fieldChanged = true\n          newFieldState.filterOptions = incomingState[path].filterOptions\n        }\n      }\n\n      /**\n       * Handle adding all the remaining props that should be updated in the local form state from the server form state\n       */\n      serverPropsToAccept.forEach((prop) => {\n        if (!dequal(incomingState[path]?.[prop], newFieldState[prop])) {\n          changed = true\n          fieldChanged = true\n          if (!(prop in incomingState[path])) {\n            // Regarding excluding the customComponents prop from being deleted: the incoming state might not have been rendered, as rendering components for every form onchange is expensive.\n            // Thus, we simply re-use the initial render state\n            if (prop !== 'customComponents') {\n              delete newFieldState[prop]\n            }\n          } else {\n            newFieldState[prop] = incomingState[path][prop]\n          }\n        }\n      })\n\n      if (newFieldState.valid !== false) {\n        newFieldState.valid = true\n      }\n      if (newFieldState.passesCondition !== false) {\n        newFieldState.passesCondition = true\n      }\n\n      // Conditions don't work if we don't memcopy the new state, as the object references would otherwise be the same\n      newState[path] = fieldChanged ? { ...newFieldState } : newFieldState\n    }\n\n    // Now loop over values that are part of incoming state but not part of existing state, and add them to the new state.\n    // This can happen if a new array row was added. In our local state, we simply add out stubbed `array` and `array.[index].id` entries to the local form state.\n    // However, all other array sub-fields are not added to the local state - those will be added by the server and may be incoming here.\n\n    for (const [path, field] of Object.entries(incomingState)) {\n      if (!existingState[path]) {\n        changed = true\n        newState[path] = field\n      }\n    }\n  }\n\n  return { changed, newState }\n}\n"],"mappings":"AAAA;;AACA,SAASA,MAAM,QAAQ,cAAa,CAAC;AAGrC,SAASC,eAAe,QAAQ;AAQhC;;;;;;;AAOA,OAAO,MAAMC,oBAAA,GAAuBA,CAAC;EACnCC,YAAY;EACZC,aAAa;EACbC;AAAa,CACR;EACL,IAAIC,OAAA,GAAU;EAEd,MAAMC,QAAA,GAAW,CAAC;EAElB,IAAIH,aAAA,EAAe;IACjB,MAAMI,mBAAA,GAAsB,CAC1B,mBACA,SACA,gBACA,cACA,QACA,oBACA,iBACD;IAED,IAAIL,YAAA,EAAc;MAChBK,mBAAA,CAAoBC,IAAI,CAAC;MACzBD,mBAAA,CAAoBC,IAAI,CAAC;IAC3B;IAEA,KAAK,MAAM,CAACC,IAAA,EAAMC,aAAA,CAAc,IAAIC,MAAA,CAAOC,OAAO,CAACT,aAAA,GAAgB;MACjE,IAAI,CAACC,aAAa,CAACK,IAAA,CAAK,EAAE;QACxB;MACF;MACA,IAAII,YAAA,GAAe;MAEnB;;;MAGA,MAAMC,gBAAA,GAAmBd,eAAA,CACvBU,aAAA,CAAcK,UAAU,EACxBX,aAAa,CAACK,IAAA,CAAK,CAACM,UAAU;MAEhC,IAAID,gBAAA,CAAiBE,MAAM,EAAE;QAC3B,IAAIF,gBAAA,CAAiBT,OAAO,EAAE;UAC5BA,OAAA,GAAUS,gBAAA,CAAiBT,OAAO;QACpC;QACAK,aAAA,CAAcK,UAAU,GAAGD,gBAAA,CAAiBE,MAAM;MACpD;MAEA;;;MAGA,IAAIZ,aAAa,CAACK,IAAA,CAAK,EAAEQ,aAAA,IAAiBP,aAAA,CAAcO,aAAa,EAAE;QACrE,IAAI,CAAClB,MAAA,CAAOK,aAAa,CAACK,IAAA,CAAK,EAAEQ,aAAA,EAAeP,aAAA,CAAcO,aAAa,GAAG;UAC5EZ,OAAA,GAAU;UACVQ,YAAA,GAAe;UACfH,aAAA,CAAcO,aAAa,GAAGb,aAAa,CAACK,IAAA,CAAK,CAACQ,aAAa;QACjE;MACF;MAEA;;;MAGAV,mBAAA,CAAoBW,OAAO,CAAEC,IAAA;QAC3B,IAAI,CAACpB,MAAA,CAAOK,aAAa,CAACK,IAAA,CAAK,GAAGU,IAAA,CAAK,EAAET,aAAa,CAACS,IAAA,CAAK,GAAG;UAC7Dd,OAAA,GAAU;UACVQ,YAAA,GAAe;UACf,IAAI,EAAEM,IAAA,IAAQf,aAAa,CAACK,IAAA,CAAK,CAAD,EAAI;YAClC;YACA;YACA,IAAIU,IAAA,KAAS,oBAAoB;cAC/B,OAAOT,aAAa,CAACS,IAAA,CAAK;YAC5B;UACF,OAAO;YACLT,aAAa,CAACS,IAAA,CAAK,GAAGf,aAAa,CAACK,IAAA,CAAK,CAACU,IAAA,CAAK;UACjD;QACF;MACF;MAEA,IAAIT,aAAA,CAAcU,KAAK,KAAK,OAAO;QACjCV,aAAA,CAAcU,KAAK,GAAG;MACxB;MACA,IAAIV,aAAA,CAAcW,eAAe,KAAK,OAAO;QAC3CX,aAAA,CAAcW,eAAe,GAAG;MAClC;MAEA;MACAf,QAAQ,CAACG,IAAA,CAAK,GAAGI,YAAA,GAAe;QAAE,GAAGH;MAAc,IAAIA,aAAA;IACzD;IAEA;IACA;IACA;IAEA,KAAK,MAAM,CAACD,IAAA,EAAMa,KAAA,CAAM,IAAIX,MAAA,CAAOC,OAAO,CAACR,aAAA,GAAgB;MACzD,IAAI,CAACD,aAAa,CAACM,IAAA,CAAK,EAAE;QACxBJ,OAAA,GAAU;QACVC,QAAQ,CAACG,IAAA,CAAK,GAAGa,KAAA;MACnB;IACF;EACF;EAEA,OAAO;IAAEjB,OAAA;IAASC;EAAS;AAC7B","ignoreList":[]}