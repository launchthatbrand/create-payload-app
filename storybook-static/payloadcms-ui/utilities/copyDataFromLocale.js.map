{"version":3,"file":"copyDataFromLocale.js","names":["ObjectIdImport","formatErrors","fieldAffectsData","fieldShouldBeLocalized","tabHasName","ObjectId","default","iterateFields","fields","fromLocaleData","toLocaleData","req","parentIsLocalized","map","field","type","name","undefined","includes","item","index","id","toHexString","localized","blockData","block","payload","blocks","blockType","blockReferences","find","slug","length","tabs","tab","mergeData","copyDataFromLocaleHandler","args","copyDataFromLocale","err","logger","error","msg","fromLocale","toLocale","message","collectionSlug","docID","globalSlug","overrideData","collections","globals","user","incomingUserSlug","collection","adminUserSlug","config","admin","adminAccessFunction","access","canAccessAdmin","Error","Promise","allSettled","findGlobal","depth","locale","overrideAccess","findByID","joins","status","fromLocaleDataWithoutID","value","updateGlobal","data","update"],"sources":["../../src/utilities/copyDataFromLocale.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\nimport {\n  type CollectionSlug,\n  type Data,\n  type Field,\n  type FlattenedBlock,\n  formatErrors,\n  type PayloadRequest,\n} from 'payload'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from 'payload/shared'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport type CopyDataFromLocaleArgs = {\n  collectionSlug?: CollectionSlug\n  docID?: number | string\n  fromLocale: string\n  globalSlug?: string\n  overrideData?: boolean\n  req: PayloadRequest\n  toLocale: string\n}\n\nfunction iterateFields(\n  fields: Field[],\n  fromLocaleData: Data,\n  toLocaleData: Data,\n  req: PayloadRequest,\n  parentIsLocalized: boolean,\n): void {\n  fields.map((field) => {\n    if (fieldAffectsData(field)) {\n      switch (field.type) {\n        case 'array':\n          // if the field has no value, take the source value\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null or undefined\n            [null, undefined].includes(toLocaleData[field.name]) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n            break\n          }\n\n          // if the field has a value - loop over the data from target\n          if (field.name in toLocaleData) {\n            toLocaleData[field.name].map((item: Data, index: number) => {\n              if (fromLocaleData[field.name]?.[index]) {\n                // Generate new IDs if the field is localized to prevent errors with relational DBs.\n                if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n                  toLocaleData[field.name][index].id = new ObjectId().toHexString()\n                }\n\n                iterateFields(\n                  field.fields,\n                  fromLocaleData[field.name][index],\n                  item,\n                  req,\n                  parentIsLocalized || field.localized,\n                )\n              }\n            })\n          }\n          break\n\n        case 'blocks':\n          // if the field has no value, take the source value\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null or undefined\n            [null, undefined].includes(toLocaleData[field.name]) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n            break\n          }\n\n          // if the field has a value - loop over the data from target\n          if (field.name in toLocaleData) {\n            toLocaleData[field.name].map((blockData: Data, index: number) => {\n              const block =\n                req.payload.blocks[blockData.blockType] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (block) => typeof block !== 'string' && block.slug === blockData.blockType,\n                ) as FlattenedBlock | undefined)\n\n              // Generate new IDs if the field is localized to prevent errors with relational DBs.\n              if (fieldShouldBeLocalized({ field, parentIsLocalized })) {\n                toLocaleData[field.name][index].id = new ObjectId().toHexString()\n              }\n\n              if (block?.fields?.length) {\n                iterateFields(\n                  block?.fields,\n                  fromLocaleData[field.name][index],\n                  blockData,\n                  req,\n                  parentIsLocalized || field.localized,\n                )\n              }\n            })\n          }\n\n          break\n\n        case 'checkbox':\n        case 'code':\n        case 'date':\n        case 'email':\n        case 'json':\n        case 'number':\n        case 'point':\n        case 'radio':\n        case 'relationship':\n        case 'richText':\n        case 'select':\n        case 'text':\n        case 'textarea':\n        case 'upload':\n          if (\n            field.name in toLocaleData &&\n            // only replace if the target value is null or undefined\n            [null, undefined].includes(toLocaleData[field.name]) &&\n            field.name in fromLocaleData\n          ) {\n            toLocaleData[field.name] = fromLocaleData[field.name]\n          }\n          break\n\n        case 'group': {\n          if (field.name in toLocaleData && fromLocaleData?.[field.name] !== undefined) {\n            iterateFields(\n              field.fields,\n              fromLocaleData[field.name],\n              toLocaleData[field.name],\n              req,\n              parentIsLocalized || field.localized,\n            )\n          }\n          break\n        }\n      }\n    } else {\n      switch (field.type) {\n        case 'collapsible':\n        case 'row':\n          iterateFields(field.fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n          break\n\n        case 'tabs':\n          field.tabs.map((tab) => {\n            if (tabHasName(tab)) {\n              if (tab.name in toLocaleData && fromLocaleData?.[tab.name] !== undefined) {\n                iterateFields(\n                  tab.fields,\n                  fromLocaleData[tab.name],\n                  toLocaleData[tab.name],\n                  req,\n                  parentIsLocalized,\n                )\n              }\n            } else {\n              iterateFields(tab.fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n            }\n          })\n          break\n      }\n    }\n  })\n}\n\nfunction mergeData(\n  fromLocaleData: Data,\n  toLocaleData: Data,\n  fields: Field[],\n  req: PayloadRequest,\n  parentIsLocalized: boolean,\n): Data {\n  iterateFields(fields, fromLocaleData, toLocaleData, req, parentIsLocalized)\n\n  return toLocaleData\n}\n\nexport const copyDataFromLocaleHandler = async (args: CopyDataFromLocaleArgs) => {\n  const { req } = args\n\n  try {\n    return await copyDataFromLocale(args)\n  } catch (err) {\n    req.payload.logger.error({\n      err,\n      msg: `There was an error copying data from \"${args.fromLocale}\" to \"${args.toLocale}\"`,\n    })\n\n    if (err.message === 'Unauthorized') {\n      return null\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const copyDataFromLocale = async (args: CopyDataFromLocaleArgs) => {\n  const {\n    collectionSlug,\n    docID,\n    fromLocale,\n    globalSlug,\n    overrideData = false,\n    req: {\n      payload,\n      payload: { collections, globals },\n      user,\n    },\n    req,\n    toLocale,\n  } = args\n\n  const incomingUserSlug = user?.collection\n\n  const adminUserSlug = payload.config.admin.user\n\n  // If we have a user slug, test it against the functions\n  if (incomingUserSlug) {\n    const adminAccessFunction = payload.collections[incomingUserSlug].config.access?.admin\n\n    // Run the admin access function from the config if it exists\n    if (adminAccessFunction) {\n      const canAccessAdmin = await adminAccessFunction({ req: args.req })\n\n      if (!canAccessAdmin) {\n        throw new Error('Unauthorized')\n      }\n      // Match the user collection to the global admin config\n    } else if (adminUserSlug !== incomingUserSlug) {\n      throw new Error('Unauthorized')\n    }\n  }\n\n  const [fromLocaleData, toLocaleData] = await Promise.allSettled([\n    globalSlug\n      ? payload.findGlobal({\n          slug: globalSlug,\n          depth: 0,\n          locale: fromLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        })\n      : payload.findByID({\n          id: docID,\n          collection: collectionSlug,\n          depth: 0,\n          joins: false,\n          locale: fromLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        }),\n    globalSlug\n      ? payload.findGlobal({\n          slug: globalSlug,\n          depth: 0,\n          locale: toLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        })\n      : payload.findByID({\n          id: docID,\n          collection: collectionSlug,\n          depth: 0,\n          joins: false,\n          locale: toLocale,\n          overrideAccess: false,\n          user,\n          // `select` would allow us to select only the fields we need in the future\n        }),\n  ])\n\n  if (fromLocaleData.status === 'rejected') {\n    throw new Error(`Error fetching data from locale \"${fromLocale}\"`)\n  }\n\n  if (toLocaleData.status === 'rejected') {\n    throw new Error(`Error fetching data from locale \"${toLocale}\"`)\n  }\n\n  const { id, ...fromLocaleDataWithoutID } = fromLocaleData.value\n\n  return globalSlug\n    ? await payload.updateGlobal({\n        slug: globalSlug,\n        data: overrideData\n          ? fromLocaleDataWithoutID\n          : mergeData(\n              fromLocaleData.value,\n              toLocaleData.value,\n              globals[globalSlug].config.fields,\n              req,\n              false,\n            ),\n        locale: toLocale,\n        overrideAccess: false,\n        req,\n        user,\n      })\n    : await payload.update({\n        id: docID,\n        collection: collectionSlug,\n        data: overrideData\n          ? fromLocaleDataWithoutID\n          : mergeData(\n              fromLocaleData.value,\n              toLocaleData.value,\n              collections[collectionSlug].config.fields,\n              req,\n              false,\n            ),\n        locale: toLocale,\n        overrideAccess: false,\n        req,\n        user,\n      })\n}\n"],"mappings":"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","ignoreList":[]}