{"version":3,"file":"buildFormState.js","names":["formatErrors","getSelectMode","reduceFieldsToValues","fieldSchemasToFormState","renderField","getClientConfig","getClientSchemaMap","getSchemaMap","handleFormStateLocking","buildFormStateHandler","args","req","incomingUserSlug","user","collection","adminUserSlug","payload","config","admin","adminAccessFunction","collections","access","canAccessAdmin","Error","hasUsers","find","depth","limit","pagination","docs","length","res","buildFormState","err","logger","error","msg","message","id","idFromArgs","collectionSlug","data","incomingData","docPermissions","docPreferences","documentFormState","formState","globalSlug","initialBlockData","initialBlockFormState","operation","renderAllFields","i18n","returnLockStatus","schemaPath","select","skipValidation","updateLastEdited","selectMode","undefined","schemaMap","clientSchemaMap","importMap","fieldOrEntityConfig","get","fields","type","documentData","blockData","Array","isArray","formStateResult","clientFieldSchemaMap","fieldSchemaMap","permissions","preferences","previousFormState","renderFieldFn","upload","file","lockedStateResult","lockedState","state"],"sources":["../../src/utilities/buildFormState.ts"],"sourcesContent":["import type { BuildFormStateArgs, ClientConfig, ClientUser, ErrorResult, FormState } from 'payload'\n\nimport { formatErrors } from 'payload'\nimport { getSelectMode, reduceFieldsToValues } from 'payload/shared'\n\nimport { fieldSchemasToFormState } from '../forms/fieldSchemasToFormState/index.js'\nimport { renderField } from '../forms/fieldSchemasToFormState/renderField.js'\nimport { getClientConfig } from './getClientConfig.js'\nimport { getClientSchemaMap } from './getClientSchemaMap.js'\nimport { getSchemaMap } from './getSchemaMap.js'\nimport { handleFormStateLocking } from './handleFormStateLocking.js'\n\nexport type LockedState = {\n  isLocked: boolean\n  lastEditedAt: string\n  user: ClientUser | number | string\n}\n\ntype BuildFormStateSuccessResult = {\n  clientConfig?: ClientConfig\n  errors?: never\n  indexPath?: string\n  lockedState?: LockedState\n  state: FormState\n}\n\ntype BuildFormStateErrorResult = {\n  lockedState?: never\n  state?: never\n} & (\n  | {\n      message: string\n    }\n  | ErrorResult\n)\n\nexport type BuildFormStateResult = BuildFormStateErrorResult | BuildFormStateSuccessResult\n\nexport const buildFormStateHandler = async (\n  args: BuildFormStateArgs,\n): Promise<BuildFormStateResult> => {\n  const { req } = args\n\n  const incomingUserSlug = req.user?.collection\n  const adminUserSlug = req.payload.config.admin.user\n\n  try {\n    // If we have a user slug, test it against the functions\n    if (incomingUserSlug) {\n      const adminAccessFunction = req.payload.collections[incomingUserSlug].config.access?.admin\n\n      // Run the admin access function from the config if it exists\n      if (adminAccessFunction) {\n        const canAccessAdmin = await adminAccessFunction({ req })\n\n        if (!canAccessAdmin) {\n          throw new Error('Unauthorized')\n        }\n        // Match the user collection to the global admin config\n      } else if (adminUserSlug !== incomingUserSlug) {\n        throw new Error('Unauthorized')\n      }\n    } else {\n      const hasUsers = await req.payload.find({\n        collection: adminUserSlug,\n        depth: 0,\n        limit: 1,\n        pagination: false,\n      })\n\n      // If there are users, we should not allow access because of /create-first-user\n      if (hasUsers.docs.length) {\n        throw new Error('Unauthorized')\n      }\n    }\n\n    const res = await buildFormState(args)\n    return res\n  } catch (err) {\n    req.payload.logger.error({ err, msg: `There was an error building form state` })\n\n    if (err.message === 'Could not find field schema for given path') {\n      return {\n        message: err.message,\n      }\n    }\n\n    if (err.message === 'Unauthorized') {\n      return null\n    }\n\n    return formatErrors(err)\n  }\n}\n\nexport const buildFormState = async (\n  args: BuildFormStateArgs,\n): Promise<BuildFormStateSuccessResult> => {\n  const {\n    id: idFromArgs,\n    collectionSlug,\n    data: incomingData,\n    docPermissions,\n    docPreferences,\n    documentFormState,\n    formState,\n    globalSlug,\n    initialBlockData,\n    initialBlockFormState,\n    operation,\n    renderAllFields,\n    req,\n    req: {\n      i18n,\n      payload,\n      payload: { config },\n    },\n    returnLockStatus,\n    schemaPath = collectionSlug || globalSlug,\n    select,\n    skipValidation,\n    updateLastEdited,\n  } = args\n\n  const selectMode = select ? getSelectMode(select) : undefined\n\n  let data = incomingData\n\n  if (!collectionSlug && !globalSlug) {\n    throw new Error('Either collectionSlug or globalSlug must be provided')\n  }\n\n  const schemaMap = getSchemaMap({\n    collectionSlug,\n    config,\n    globalSlug,\n    i18n,\n  })\n\n  const clientSchemaMap = getClientSchemaMap({\n    collectionSlug,\n    config: getClientConfig({ config, i18n, importMap: req.payload.importMap }),\n    globalSlug,\n    i18n,\n    payload,\n    schemaMap,\n  })\n\n  const id = collectionSlug ? idFromArgs : undefined\n  const fieldOrEntityConfig = schemaMap.get(schemaPath)\n\n  if (!fieldOrEntityConfig) {\n    throw new Error(`Could not find \"${schemaPath}\" in the fieldSchemaMap`)\n  }\n\n  if (\n    (!('fields' in fieldOrEntityConfig) ||\n      !fieldOrEntityConfig.fields ||\n      !fieldOrEntityConfig.fields.length) &&\n    'type' in fieldOrEntityConfig &&\n    fieldOrEntityConfig.type !== 'blocks'\n  ) {\n    throw new Error(\n      `The field found in fieldSchemaMap for \"${schemaPath}\" does not contain any subfields.`,\n    )\n  }\n\n  // If there is a form state,\n  // then we can deduce data from that form state\n  if (formState) {\n    data = reduceFieldsToValues(formState, true)\n  }\n\n  let documentData = undefined\n  if (documentFormState) {\n    documentData = reduceFieldsToValues(documentFormState, true)\n  }\n\n  let blockData = initialBlockData\n  if (initialBlockFormState) {\n    blockData = reduceFieldsToValues(initialBlockFormState, true)\n  }\n\n  /**\n   * When building state for sub schemas we need to adjust:\n   * - `fields`\n   * - `parentSchemaPath`\n   * - `parentPath`\n   *\n   * Type assertion is fine because we wrap sub schemas in an array\n   * so we can safely map over them within `fieldSchemasToFormState`\n   */\n  const fields = Array.isArray(fieldOrEntityConfig)\n    ? fieldOrEntityConfig\n    : 'fields' in fieldOrEntityConfig\n      ? fieldOrEntityConfig.fields\n      : [fieldOrEntityConfig]\n\n  const formStateResult = await fieldSchemasToFormState({\n    id,\n    clientFieldSchemaMap: clientSchemaMap,\n    collectionSlug,\n    data,\n    documentData,\n    fields,\n    fieldSchemaMap: schemaMap,\n    initialBlockData: blockData,\n    operation,\n    permissions: docPermissions?.fields || {},\n    preferences: docPreferences || { fields: {} },\n    previousFormState: formState,\n    renderAllFields,\n    renderFieldFn: renderField,\n    req,\n    schemaPath,\n    select,\n    selectMode,\n    skipValidation,\n  })\n\n  // Maintain form state of auth / upload fields\n  if (collectionSlug && formState) {\n    if (payload.collections[collectionSlug]?.config?.upload && formState.file) {\n      formStateResult.file = formState.file\n    }\n  }\n\n  let lockedStateResult\n\n  if (returnLockStatus) {\n    lockedStateResult = await handleFormStateLocking({\n      id,\n      collectionSlug,\n      globalSlug,\n      req,\n      updateLastEdited,\n    })\n  }\n\n  return {\n    lockedState: lockedStateResult,\n    state: formStateResult,\n  }\n}\n"],"mappings":"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","ignoreList":[]}